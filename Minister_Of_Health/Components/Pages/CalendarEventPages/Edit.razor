@page "/calendarevents/edit/{Id:int}"
@using Microsoft.EntityFrameworkCore
@using Minister_Of_Time.Domain
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using System.ComponentModel.DataAnnotations
@inject IDbContextFactory<Minister_Of_Time.Data.Minister_Of_TimeContext> DbFactory
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthStateProvider
@rendermode InteractiveServer

<div class="container mt-5">
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="/calendarevents">Calendar</a></li>
            <li class="breadcrumb-item active">Edit Event</li>
        </ol>
    </nav>

    <div class="card shadow-lg p-4">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2 class="mb-0">Edit Event</h2>
            @* FIX: Editors can now see the delete button too *@
            @if (isHost || isEditor)
            {
                <button class="btn btn-outline-danger" @onclick="() => showDeletePopup = true">
                    <i class="bi bi-trash me-2"></i>Delete Event
                </button>
            }
        </div>

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger shadow-sm">
                <i class="bi bi-exclamation-octagon-fill me-2"></i> @errorMessage
            </div>
        }

        @if (CalendarEvent is null)
        {
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status"></div>
                <p class="mt-2">Loading event...</p>
            </div>
        }
        else
        {
            <EditForm Model="Input" OnValidSubmit="UpdateCalendarEvent" FormName="editEventForm">
                <DataAnnotationsValidator />

                <div class="row">
                    <div class="col-md-6 mb-3">
                        <label class="form-label fw-bold">Event Name</label>
                        <InputText @bind-Value="Input.EventName" class="form-control" placeholder="What's happening?" />
                        <ValidationMessage For="() => Input.EventName" class="text-danger" />
                    </div>
                    <div class="col-md-6 mb-3">
                        <label class="form-label fw-bold">Location</label>
                        <InputText @bind-Value="Input.Location" class="form-control" placeholder="Physical or Digital address" />
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6 mb-3">
                        <label class="form-label fw-bold">Start Date & Time</label>
                        <InputDate Type="InputDateType.DateTimeLocal" @bind-Value="Input.StartDateTime" @bind-Value:after="SyncDates" class="form-control" />
                        <ValidationMessage For="() => Input.StartDateTime" class="text-danger" />
                    </div>
                    <div class="col-md-6 mb-3">
                        <label class="form-label fw-bold">End Date & Time</label>
                        <InputDate Type="InputDateType.DateTimeLocal" @bind-Value="Input.EndDateTime" class="form-control" />
                        <ValidationMessage For="() => Input.EndDateTime" class="text-danger" />
                    </div>
                </div>

                <div class="mb-3">
                    <label class="form-label fw-bold">Description</label>
                    <InputTextArea @bind-Value="Input.Description" class="form-control" rows="3" placeholder="Add event details..." />
                </div>

                <div class="d-flex justify-content-end gap-2 mt-4">
                    <a href="/calendarevents" class="btn btn-light border">Cancel</a>
                    <button type="submit" class="btn btn-primary px-4" disabled="@isSubmitting">
                        <i class="bi bi-check-circle me-2"></i>Save Changes
                    </button>
                </div>
            </EditForm>
        }
    </div>
</div>

@* --- DELETE CONFIRMATION POPUP --- *@
@if (showDeletePopup)
{
    <div class="modal fade show d-block" style="background: rgba(0,0,0,0.5);" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content border-0 shadow-lg">
                <div class="modal-body text-center py-4">
                    <i class="bi bi-exclamation-triangle text-danger" style="font-size: 3rem;"></i>
                    <h5 class="mt-3">Delete Event?</h5>
                    <p class="text-muted">This action cannot be undone. All participants will be notified.</p>
                    <div class="d-flex gap-2 justify-content-center mt-4">
                        <button class="btn btn-light border px-4" @onclick="() => showDeletePopup = false">Cancel</button>
                        <button class="btn btn-danger px-4" @onclick="DeleteEvent">
                            <i class="bi bi-trash me-2"></i>Delete
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public int Id { get; set; }
    [SupplyParameterFromForm] private EventInputModel Input { get; set; } = new();

    private CalendarEvent? CalendarEvent;
    private string? errorMessage;
    private bool isSubmitting = false;
    private bool showDeletePopup = false;
    private bool isHost = false;
    private bool isEditor = false;
    private string? currentUserId;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        currentUserId = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        using var context = DbFactory.CreateDbContext();
        CalendarEvent = await context.CalendarEvent
            .Include(e => e.UserActivity)
            .FirstOrDefaultAsync(m => m.Id == Id);

        if (CalendarEvent is null)
        {
            NavigationManager.NavigateTo("/calendarevents");
            return;
        }

        // Check Roles
        isHost = CalendarEvent.HostUserId == currentUserId;

        var userRole = await context.EventParticipant
            .Include(p => p.EventRole)
            .FirstOrDefaultAsync(p => p.CalendarEventId == Id && p.UserId == currentUserId);

        isEditor = userRole?.EventRole?.RoleName == "Editor";

        // Populate form
        Input.EventName = CalendarEvent.EventName;
        Input.Location = CalendarEvent.Location ?? "";
        Input.StartDateTime = CalendarEvent.StartDateTime;
        Input.EndDateTime = CalendarEvent.EndDateTime;
        Input.Description = CalendarEvent.Description ?? "";
    }

    private void SyncDates()
    {
        if (Input.StartDateTime >= Input.EndDateTime)
        {
            Input.EndDateTime = Input.StartDateTime.AddHours(1);
        }
    }

    private async Task UpdateCalendarEvent()
    {
        errorMessage = null;
        if (Input.EndDateTime <= Input.StartDateTime)
        {
            errorMessage = "End time must be after start time.";
            return;
        }

        isSubmitting = true;

        try
        {
            using var context = DbFactory.CreateDbContext();
            var eventToUpdate = await context.CalendarEvent.FindAsync(Id);

            if (eventToUpdate == null) return;

            // STATUS CHECK: Postponed vs Brought Forward
            if (Input.StartDateTime > eventToUpdate.StartDateTime)
            {
                eventToUpdate.Status = "Postponed";
            }
            else if (Input.StartDateTime < eventToUpdate.StartDateTime)
            {
                eventToUpdate.Status = "Brought Forward";
            }

            // Update fields
            eventToUpdate.EventName = Input.EventName;
            eventToUpdate.Location = Input.Location;
            eventToUpdate.StartDateTime = Input.StartDateTime;
            eventToUpdate.EndDateTime = Input.EndDateTime;
            eventToUpdate.Description = Input.Description;
            eventToUpdate.DateUpdated = DateTime.Now;

            await context.SaveChangesAsync();

            // Notify participants (Logic to prevent duplicates should be in your notification service,
            // but here we ensure we only grab unique UserIds who aren't the person editing)
            var uniqueParticipants = await context.EventParticipant
                .Where(p => p.CalendarEventId == Id && p.UserId != null && p.UserId != currentUserId)
                .GroupBy(p => p.UserId)
                .Select(g => g.First())
                .ToListAsync();

            foreach (var participant in uniqueParticipants)
            {
                context.EventParticipant.Add(new EventParticipant
                {
                    CalendarEventId = Id,
                    UserId = participant.UserId,
                    ParticipationStatus = "UpdateNotification",
                    CustomActivity = $"Status: {eventToUpdate.Status}. Event Updated: {Input.EventName}"
                });
            }

            await context.SaveChangesAsync();
            NavigationManager.NavigateTo("/calendarevents");
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
            isSubmitting = false;
        }
    }

    private async Task DeleteEvent()
    {
        try
        {
            using var context = DbFactory.CreateDbContext();
            var eventToDelete = await context.CalendarEvent.FindAsync(Id);
            if (eventToDelete == null) return;

            // PREVENTING MULTIPLE REMOVALS / HOST PROTECTION
            // 1. Get unique list of participants to notify
            var participantsToNotify = await context.EventParticipant
                .Where(p => p.CalendarEventId == Id && p.UserId != null)
                .GroupBy(p => p.UserId)
                .Select(g => g.First())
                .ToListAsync();

            foreach (var p in participantsToNotify)
            {
                // Logic to skip removing host if the person deleting is an editor
                if (isEditor && p.UserId == eventToDelete.HostUserId) continue;

                context.EventParticipant.Add(new EventParticipant
                {
                    CalendarEventId = 0,
                    UserId = p.UserId,
                    ParticipationStatus = "DeleteNotification",
                    CustomActivity = $"Event Deleted: {eventToDelete.EventName}"
                });
            }

            // Delete participants (but keep notification records if your schema allows)
            var existingLinks = await context.EventParticipant.Where(p => p.CalendarEventId == Id).ToListAsync();
            context.EventParticipant.RemoveRange(existingLinks);

            context.CalendarEvent.Remove(eventToDelete);
            await context.SaveChangesAsync();

            NavigationManager.NavigateTo("/calendarevents");
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
            showDeletePopup = false;
        }
    }

    private sealed class EventInputModel
    {
        [Required] public string EventName { get; set; } = "";
        [Required] public string Location { get; set; } = "";
        [Required] public DateTime StartDateTime { get; set; }
        [Required] public DateTime EndDateTime { get; set; }
        public string Description { get; set; } = "";
    }
}