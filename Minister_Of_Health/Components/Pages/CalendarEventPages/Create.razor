@page "/calendarevents/create"
@using Microsoft.EntityFrameworkCore
@using Minister_Of_Time.Domain
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using System.ComponentModel.DataAnnotations
@inject IDbContextFactory<Minister_Of_Time.Data.Minister_Of_TimeContext> DbFactory
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthStateProvider
@rendermode InteractiveServer

<div class="container mt-5">
    <div class="card shadow-lg p-4">
        <h2 class="mb-4">Schedule New Event</h2>

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger shadow-sm">
                <i class="bi bi-exclamation-octagon-fill me-2"></i> @errorMessage
            </div>
        }

        <EditForm Model="Input" OnValidSubmit="AddCalendarEvent" FormName="createEventForm">
            <DataAnnotationsValidator />

            <div class="row">
                <div class="col-md-6 mb-3">
                    <label class="form-label fw-bold">Event Name</label>
                    <InputText @bind-Value="Input.EventName" class="form-control" placeholder="What's happening?" />
                    <ValidationMessage For="() => Input.EventName" class="text-danger" />
                </div>
                <div class="col-md-6 mb-3">
                    <label class="form-label fw-bold">Location</label>
                    <InputText @bind-Value="Input.Location" class="form-control" placeholder="Physical or Digital address" />
                </div>
            </div>

            <div class="row">
                <div class="col-md-4 mb-3">
                    <label class="form-label fw-bold">Start Date & Time</label>
                    <InputDate Type="InputDateType.DateTimeLocal" @bind-Value="Input.StartDateTime" @bind-Value:after="SyncDates" class="form-control" />
                    <ValidationMessage For="() => Input.StartDateTime" class="text-danger" />
                </div>
                <div class="col-md-4 mb-3">
                    <label class="form-label fw-bold">End Date & Time</label>
                    <InputDate Type="InputDateType.DateTimeLocal" @bind-Value="Input.EndDateTime" class="form-control" />
                    <ValidationMessage For="() => Input.EndDateTime" class="text-danger" />
                </div>
                <div class="col-md-4 mb-3">
                    <label class="form-label fw-bold">Activity</label>
                    <div class="d-flex gap-2">
                        <InputSelect @bind-Value="Input.UserActivityId" @bind-Value:after="OnActivityChanged" class="form-select">
                            <option value="0">-- Select Activity --</option>
                            @foreach (var activity in Suggestions)
                            {
                                <option value="@activity.Id">@activity.Name (@(activity.ActivityType ?? "Others"))</option>
                            }
                        </InputSelect>
                        <a href="/useractivities/create" class="btn btn-outline-primary" title="New Activity">+</a>
                    </div>
                    <ValidationMessage For="() => Input.UserActivityId" class="text-danger" />
                    @if (!string.IsNullOrEmpty(selectedActivityType))
                    {
                        <small class="text-muted d-block mt-1">
                            Type: <span class="badge @GetActivityTypeBadge(selectedActivityType)">@selectedActivityType</span>
                            @if (!string.IsNullOrEmpty(selectedCategory))
                            {
                                <span class="ms-2">Category: <span class="badge bg-secondary">@selectedCategory</span></span>
                            }
                        </small>
                    }
                </div>
            </div>

            <div class="mb-3">
                <label class="form-label fw-bold d-block">Invite Users</label>

                <div class="mb-2 p-2 border rounded bg-light" style="min-height: 40px;">
                    @if (!inviteStatusList.Any())
                    {
                        <span class="text-muted small fst-italic">Enter emails separated by commas...</span>
                    }
                    @foreach (var status in inviteStatusList)
                    {
                        @if (status.IsDuplicate)
                        {
                            <span class="badge bg-danger me-1" title="Duplicate or Host Email">
                                @status.Email <i class="bi bi-exclamation-triangle-fill"></i>
                            </span>
                        }
                        else if (!status.IsValidRole)
                        {
                            <span class="badge bg-danger me-1" title="Invalid Role - Only 'Editor' or 'Viewer' allowed">
                                @status.Email (@status.RoleName) <i class="bi bi-x-circle-fill"></i>
                            </span>
                        }
                        else
                        {
                            <span class="badge @(status.IsRegistered ? "bg-success" : "bg-warning text-dark") me-1">
                                @status.Email (@status.RoleName) @(status.IsRegistered ? "✓" : "?")
                            </span>
                        }
                    }
                </div>

                <InputTextArea @bind-Value="Input.InvitedEmails"
                               @oninput="OnInviteInputChanged"
                               class="form-control" rows="2"
                               placeholder="user@email.com, friend@email.com (Editor)" />
                <small class="text-muted">Separate multiple emails with commas. Valid roles: <strong>Editor</strong> or <strong>Viewer</strong> (default). Example: user@email.com (Editor)</small>
            </div>

            <div class="mb-3">
                <label class="form-label fw-bold">Description</label>
                <InputTextArea @bind-Value="Input.Description" class="form-control" rows="3" placeholder="Add event details..." />
            </div>

            <div class="d-flex justify-content-end gap-2 mt-4">
                <a href="/calendarevents" class="btn btn-light border">Cancel</a>
                <button type="submit" class="btn btn-primary px-4" disabled="@isSubmitting">
                    <i class="bi bi-calendar-check me-2"></i>Create Event
                </button>
            </div>
        </EditForm>
    </div>
</div>

@code {
    private string? errorMessage;
    private bool isSubmitting = false;
    private List<UserActivity> Suggestions = new();
    private List<EmailStatus> inviteStatusList = new();
    private string? selectedActivityType;
    private string? selectedCategory;

    private class EmailStatus
    {
        public string Email { get; set; } = "";
        public string RoleName { get; set; } = "Viewer";
        public bool IsRegistered { get; set; }
        public bool IsDuplicate { get; set; }
        public bool IsValidRole { get; set; } = true;
    }

    [SupplyParameterFromForm] private EventInputModel Input { get; set; } = new();
    [SupplyParameterFromQuery] private string? Date { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Initialize with query parameter date or default to now
        if (!string.IsNullOrEmpty(Date) && DateTime.TryParse(Date, out var parsedDate))
        {
            Input.StartDateTime = parsedDate;
            Input.EndDateTime = parsedDate.AddHours(1);
        }
        else if (Input.StartDateTime == default)
        {
            Input.StartDateTime = DateTime.Now;
            Input.EndDateTime = DateTime.Now.AddHours(1);
        }

        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var userIdStr = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        if (!string.IsNullOrEmpty(userIdStr))
        {
            using var context = DbFactory.CreateDbContext();
            Suggestions = await context.UserActivity
                .Where(a => a.UserId == userIdStr)
                .OrderBy(a => a.ActivityType)
                .ThenBy(a => a.Name)
                .ToListAsync();
        }
    }

    private void OnActivityChanged()
    {
        if (Input.UserActivityId > 0)
        {
            var activity = Suggestions.FirstOrDefault(a => a.Id == Input.UserActivityId);
            if (activity != null)
            {
                selectedActivityType = activity.ActivityType ?? "Others";
                selectedCategory = activity.Category;
            }
        }
        else
        {
            selectedActivityType = null;
            selectedCategory = null;
        }
    }

    private string GetActivityTypeBadge(string activityType)
    {
        return activityType switch
        {
            "Work" => "bg-primary text-white",
            "Meetings" => "bg-info text-dark",
            "Hobby" => "bg-success text-white",
            "Life" => "bg-warning text-dark",
            "Family Time" => "bg-danger text-white",
            "Others" => "bg-secondary text-white",
            _ => "bg-secondary text-white"
        };
    }

    private void SyncDates()
    {
        if (Input.StartDateTime >= Input.EndDateTime)
        {
            Input.EndDateTime = Input.StartDateTime.AddHours(1);
        }
    }

    private async Task OnInviteInputChanged(ChangeEventArgs e)
    {
        Input.InvitedEmails = e.Value?.ToString() ?? "";
        var parsed = ParseInvites(Input.InvitedEmails);
        var newList = new List<EmailStatus>();
        var seen = new HashSet<string>();

        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var hostEmail = authState.User.FindFirst(ClaimTypes.Email)?.Value?.ToLower();

        using var context = DbFactory.CreateDbContext();
        foreach (var item in parsed)
        {
            var emailLower = item.Email.ToLower();
            bool isHost = emailLower == hostEmail;
            bool duplicate = !seen.Add(emailLower) || isHost;

            // Validate role - only Editor or Viewer allowed (case-insensitive)
            var normalizedRole = item.RoleName.Trim();
            bool isValidRole = normalizedRole.Equals("Editor", StringComparison.OrdinalIgnoreCase) ||
                              normalizedRole.Equals("Viewer", StringComparison.OrdinalIgnoreCase);

            var exists = await context.Users.AnyAsync(u => u.Email.ToLower() == emailLower);

            newList.Add(new EmailStatus
            {
                Email = item.Email,
                RoleName = normalizedRole,
                IsRegistered = exists,
                IsDuplicate = duplicate,
                IsValidRole = isValidRole
            });
        }
        inviteStatusList = newList;

        // Show appropriate error messages
        if (inviteStatusList.Any(x => x.IsDuplicate))
            errorMessage = "Please remove duplicates or your own email from the invite list.";
        else if (inviteStatusList.Any(x => !x.IsValidRole))
            errorMessage = "Invalid role detected. Only 'Editor' or 'Viewer' roles are allowed.";
        else
            errorMessage = null;
    }

    private List<(string Email, string RoleName)> ParseInvites(string input)
    {
        var list = new List<(string, string)>();
        if (string.IsNullOrWhiteSpace(input)) return list;

        foreach (var p in input.Split(','))
        {
            var trimmed = p.Trim();
            var match = System.Text.RegularExpressions.Regex.Match(trimmed, @"^([^(\s]+)(?:\s*\((.+?)\))?$");
            if (match.Success)
            {
                var email = match.Groups[1].Value.Trim();
                var role = match.Groups[2].Success ? match.Groups[2].Value.Trim() : "Viewer";
                list.Add((email, role));
            }
            else if (!string.IsNullOrEmpty(trimmed))
            {
                list.Add((trimmed, "Viewer"));
            }
        }
        return list;
    }

    private async Task AddCalendarEvent()
    {
        errorMessage = null;

        // Validate activity selection
        if (Input.UserActivityId <= 0)
        {
            errorMessage = "Please select a valid activity.";
            return;
        }

        // Validate dates - cannot create events in the past
        if (Input.StartDateTime < DateTime.Now.AddMinutes(-5))
        {
            errorMessage = "Cannot create an event in the past. Please select a future date and time.";
            return;
        }

        if (Input.EndDateTime <= Input.StartDateTime)
        {
            errorMessage = "End time must be after start time.";
            return;
        }

        // Validate invites - check for duplicates
        if (inviteStatusList.Any(x => x.IsDuplicate))
        {
            errorMessage = "Please fix duplicate invites or self-invites before saving.";
            return;
        }

        // Validate invites - check for invalid roles
        if (inviteStatusList.Any(x => !x.IsValidRole))
        {
            errorMessage = "Invalid roles detected. Only 'Editor' or 'Viewer' roles are allowed.";
            return;
        }

        isSubmitting = true;

        try
        {
            using var context = DbFactory.CreateDbContext();
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var currentUserId = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            var selectedActivity = await context.UserActivity.FindAsync(Input.UserActivityId);
            if (selectedActivity == null)
            {
                errorMessage = "Selected activity not found.";
                isSubmitting = false;
                return;
            }

            var activityType = selectedActivity.ActivityType ?? "Others";
            if (!IsValidActivityType(activityType))
            {
                errorMessage = $"Invalid activity type: {activityType}. Please update the activity to have a valid type.";
                isSubmitting = false;
                return;
            }

            // Create the event with Status always set to "Upcoming"
            var newEvent = new CalendarEvent
            {
                EventName = Input.EventName,
                Location = Input.Location,
                StartDateTime = Input.StartDateTime,
                EndDateTime = Input.EndDateTime,
                HostUserId = currentUserId,
                UserActivityId = Input.UserActivityId,
                Status = "Upcoming", // Always set to Upcoming
                Description = Input.Description,
                DateCreated = DateTime.Now
            };

            context.CalendarEvent.Add(newEvent);

            // Add invites
            foreach (var invite in inviteStatusList)
            {
                var regUser = await context.Users.FirstOrDefaultAsync(u => u.Email.ToLower() == invite.Email.ToLower());

                // Normalize role to proper case
                var roleId = invite.RoleName.Equals("Editor", StringComparison.OrdinalIgnoreCase) ? 2 : 1;

                context.EventParticipant.Add(new EventParticipant
                {
                    CalendarEvent = newEvent,
                    InviteeEmail = invite.Email,
                    UserId = regUser?.Id,
                    EventRoleId = roleId,
                    ParticipationStatus = "Pending"
                });
            }

            await context.SaveChangesAsync();
            NavigationManager.NavigateTo("/calendarevents");
        }
        catch (Exception ex)
        {
            errorMessage = $"Error creating event: {ex.Message}";
            isSubmitting = false;
        }
    }

    private bool IsValidActivityType(string type)
    {
        var validTypes = new[] { "Life", "Work", "Hobby", "Meetings", "Family Time", "Others" };
        return validTypes.Contains(type, StringComparer.OrdinalIgnoreCase);
    }

    private sealed class EventInputModel
    {
        [Required(ErrorMessage = "Event name is required")]
        [StringLength(100, ErrorMessage = "Event name cannot exceed 100 characters")]
        public string EventName { get; set; } = "";

        [Required(ErrorMessage = "Location is required")]
        public string Location { get; set; } = "";

        [Range(1, int.MaxValue, ErrorMessage = "Please select an activity")]
        public int UserActivityId { get; set; }

        [Required]
        public DateTime StartDateTime { get; set; }

        [Required]
        public DateTime EndDateTime { get; set; }

        public string InvitedEmails { get; set; } = "";

        public string Description { get; set; } = "";
    }
}